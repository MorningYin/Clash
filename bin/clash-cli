#!/bin/bash
# Clash CLI 管理工具
# 作者: Auto
# 日期: 2025-10-30

# 脚本目录
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# 检测配置目录
detect_config_dir() {
    if [ -d "/etc/clash" ]; then
        CLASH_CONFIG_DIR="/etc/clash"
    elif [ -d "$HOME/.config/clash" ]; then
        CLASH_CONFIG_DIR="$HOME/.config/clash"
    else
        echo -e "${RED}错误: 找不到 Clash 配置目录${NC}"
        echo "请确保 Clash 已正确安装"
        exit 1
    fi
}

# 检测 Clash 可执行文件
detect_clash_bin() {
    if [ -f "/usr/local/bin/clash" ]; then
        CLASH_BIN="/usr/local/bin/clash"
    elif [ -f "$HOME/.local/bin/clash" ]; then
        CLASH_BIN="$HOME/.local/bin/clash"
    elif command -v clash >/dev/null 2>&1; then
        CLASH_BIN=$(command -v clash)
    else
        echo -e "${RED}错误: 找不到 Clash 可执行文件${NC}"
        echo "请确保 Clash 已正确安装"
        exit 1
    fi
}

# 检查服务是否运行
is_running() {
    local pid_file="$CLASH_CONFIG_DIR/clash.pid"
    if [ -f "$pid_file" ]; then
        local pid=$(cat "$pid_file")
        if ps -p "$pid" > /dev/null 2>&1; then
            return 0
        else
            rm -f "$pid_file"
        fi
    fi
    return 1
}

# 获取服务状态
get_status() {
    if is_running; then
        local pid=$(cat "$CLASH_CONFIG_DIR/clash.pid")
        echo -e "${GREEN}运行中${NC} (PID: $pid)"
        return 0
    else
        echo -e "${RED}未运行${NC}"
        return 1
    fi
}

# 检查端口监听
check_ports() {
    local http_port=7890
    local socks_port=7891
    local api_port=9090
    
    # 从配置文件读取端口
    if [ -f "$CLASH_CONFIG_DIR/config.yaml" ]; then
        http_port=$(grep "^port:" "$CLASH_CONFIG_DIR/config.yaml" | head -1 | sed 's/port:[[:space:]]*//' | sed 's/[[:space:]]*$//' || echo "7890")
        socks_port=$(grep "^socks-port:" "$CLASH_CONFIG_DIR/config.yaml" | head -1 | sed 's/socks-port:[[:space:]]*//' | sed 's/[[:space:]]*$//' || echo "7891")
        api_port=$(grep "^external-controller:" "$CLASH_CONFIG_DIR/config.yaml" | head -1 | sed 's/.*:\([0-9]*\).*/\1/' || echo "9090")
    fi
    
    local ports_status=()
    
    # 检查 HTTP 代理端口
    if ss -tlnp 2>/dev/null | grep -q ":$http_port "; then
        ports_status+=("HTTP代理($http_port): ${GREEN}✓${NC}")
    else
        ports_status+=("HTTP代理($http_port): ${RED}✗${NC}")
    fi
    
    # 检查 SOCKS5 代理端口
    if ss -tlnp 2>/dev/null | grep -q ":$socks_port "; then
        ports_status+=("SOCKS5代理($socks_port): ${GREEN}✓${NC}")
    else
        ports_status+=("SOCKS5代理($socks_port): ${RED}✗${NC}")
    fi
    
    # 检查 API 端口
    if ss -tlnp 2>/dev/null | grep -q ":$api_port "; then
        ports_status+=("管理面板($api_port): ${GREEN}✓${NC}")
    else
        ports_status+=("管理面板($api_port): ${RED}✗${NC}")
    fi
    
    printf '%s\n' "${ports_status[@]}"
}

# 启动服务
start_service() {
    echo -e "${BLUE}启动 Clash 服务...${NC}"
    
    if is_running; then
        echo -e "${YELLOW}Clash 服务已在运行${NC}"
        return 0
    fi
    
    # 检查配置文件
    if [ ! -f "$CLASH_CONFIG_DIR/config.yaml" ]; then
        echo -e "${RED}错误: 配置文件不存在${NC}"
        return 1
    fi
    
    # 验证配置文件
    if ! "$CLASH_BIN" -t -f "$CLASH_CONFIG_DIR/config.yaml" >/dev/null 2>&1; then
        echo -e "${RED}错误: 配置文件验证失败${NC}"
        return 1
    fi
    
    # 启动服务
    nohup "$CLASH_BIN" -d "$CLASH_CONFIG_DIR" > "$CLASH_CONFIG_DIR/clash.log" 2>&1 &
    local clash_pid=$!
    
    # 保存 PID
    echo "$clash_pid" > "$CLASH_CONFIG_DIR/clash.pid"
    
    # 等待服务启动
    sleep 2
    
    if is_running; then
        echo -e "${GREEN}Clash 服务启动成功${NC}"
        show_service_info
    else
        echo -e "${RED}Clash 服务启动失败${NC}"
        return 1
    fi
}

# 停止服务
stop_service() {
    echo -e "${BLUE}停止 Clash 服务...${NC}"
    
    if ! is_running; then
        echo -e "${YELLOW}Clash 服务未运行${NC}"
        return 0
    fi
    
    local pid=$(cat "$CLASH_CONFIG_DIR/clash.pid")
    echo "停止 Clash 进程 (PID: $pid)"
    
    # 尝试优雅停止
    kill "$pid" 2>/dev/null
    
    # 等待进程结束
    for i in {1..10}; do
        if ! ps -p "$pid" > /dev/null 2>&1; then
            rm -f "$CLASH_CONFIG_DIR/clash.pid"
            echo -e "${GREEN}Clash 服务已停止${NC}"
            return 0
        fi
        sleep 1
    done
    
    # 强制停止
    echo -e "${YELLOW}强制停止 Clash 进程${NC}"
    kill -9 "$pid" 2>/dev/null || true
    rm -f "$CLASH_CONFIG_DIR/clash.pid"
    echo -e "${GREEN}Clash 服务已强制停止${NC}"
}

# 重启服务
restart_service() {
    echo -e "${BLUE}重启 Clash 服务...${NC}"
    stop_service
    sleep 1
    start_service
}

# 显示服务信息
show_service_info() {
    echo ""
    echo -e "${CYAN}服务信息:${NC}"
    echo "  状态: $(get_status)"
    echo "  配置文件: $CLASH_CONFIG_DIR/config.yaml"
    echo "  日志文件: $CLASH_CONFIG_DIR/clash.log"
    echo ""
    
    echo -e "${CYAN}端口状态:${NC}"
    check_ports | sed 's/^/  /'
    echo ""
    
    # 显示代理信息
    local http_port=7890
    local socks_port=7891
    local api_port=9090
    
    if [ -f "$CLASH_CONFIG_DIR/config.yaml" ]; then
        http_port=$(grep "^port:" "$CLASH_CONFIG_DIR/config.yaml" | head -1 | sed 's/port:[[:space:]]*//' | sed 's/[[:space:]]*$//' || echo "7890")
        socks_port=$(grep "^socks-port:" "$CLASH_CONFIG_DIR/config.yaml" | head -1 | sed 's/socks-port:[[:space:]]*//' | sed 's/[[:space:]]*$//' || echo "7891")
        api_port=$(grep "^external-controller:" "$CLASH_CONFIG_DIR/config.yaml" | head -1 | sed 's/.*:\([0-9]*\).*/\1/' || echo "9090")
    fi
    
    echo -e "${CYAN}代理信息:${NC}"
    echo "  HTTP 代理: http://127.0.0.1:$http_port"
    echo "  SOCKS5 代理: socks5://127.0.0.1:$socks_port"
    echo "  管理面板: http://127.0.0.1:$api_port"
    echo ""
}

# 查看日志
view_logs() {
    local lines="${1:-50}"
    
    if [ -f "$CLASH_CONFIG_DIR/clash.log" ]; then
        echo -e "${BLUE}显示最近的 $lines 行日志:${NC}"
        echo ""
        tail -n "$lines" "$CLASH_CONFIG_DIR/clash.log"
    else
        echo -e "${YELLOW}日志文件不存在: $CLASH_CONFIG_DIR/clash.log${NC}"
    fi
}

# 实时查看日志
follow_logs() {
    if [ -f "$CLASH_CONFIG_DIR/clash.log" ]; then
        echo -e "${BLUE}实时查看日志 (按 Ctrl+C 退出):${NC}"
        echo ""
        tail -f "$CLASH_CONFIG_DIR/clash.log"
    else
        echo -e "${YELLOW}日志文件不存在: $CLASH_CONFIG_DIR/clash.log${NC}"
    fi
}

# 更新订阅
update_subscription() {
    echo -e "${BLUE}更新订阅配置...${NC}"
    
    local update_script="$CLASH_CONFIG_DIR/update-subscription.sh"
    if [ -f "$update_script" ]; then
        if "$update_script"; then
            echo -e "${GREEN}订阅更新成功${NC}"
            if confirm "是否重启服务以应用新配置？" "y"; then
                restart_service
            fi
        else
            echo -e "${RED}订阅更新失败${NC}"
            return 1
        fi
    else
        echo -e "${YELLOW}更新脚本不存在: $update_script${NC}"
        return 1
    fi
}

# 测试连接
test_connection() {
    echo -e "${BLUE}测试代理连接...${NC}"
    
    local http_port=7890
    if [ -f "$CLASH_CONFIG_DIR/config.yaml" ]; then
        http_port=$(grep "^port:" "$CLASH_CONFIG_DIR/config.yaml" | head -1 | sed 's/port:[[:space:]]*//' | sed 's/[[:space:]]*$//' || echo "7890")
    fi
    
    local test_url="http://www.google.com"
    local proxy_url="http://127.0.0.1:$http_port"
    
    echo "测试 HTTP 代理连接..."
    if curl -x "$proxy_url" -s -o /dev/null -w "HTTP 状态码: %{http_code}\n" "$test_url"; then
        echo -e "${GREEN}HTTP 代理连接正常${NC}"
    else
        echo -e "${RED}HTTP 代理连接失败${NC}"
        return 1
    fi
    
    # 测试响应时间
    echo "测试响应时间..."
    local response_time=$(curl -x "$proxy_url" -s -o /dev/null -w "%{time_total}" "$test_url")
    echo "响应时间: ${response_time}秒"
    
    return 0
}

# 用户确认函数
confirm() {
    local prompt="$1"
    local default="${2:-n}"
    local response
    
    if [ "$default" = "y" ]; then
        prompt="$prompt [Y/n]: "
    else
        prompt="$prompt [y/N]: "
    fi
    
    while true; do
        read -p "$prompt" response
        response=${response:-$default}
        case $response in
            [Yy]* ) return 0;;
            [Nn]* ) return 1;;
            * ) echo "请输入 y 或 n";;
        esac
    done
}

# 显示主菜单
show_menu() {
    clear
    echo -e "${BLUE}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║                    Clash 管理面板                           ║${NC}"
    echo -e "${BLUE}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo "1. 启动服务"
    echo "2. 停止服务"
    echo "3. 重启服务"
    echo "4. 查看状态"
    echo "5. 更新订阅"
    echo "6. 查看日志"
    echo "7. 测试连接"
    echo "8. 代理设置"
    echo "9. 节点管理"
    echo "10. 系统代理 (开/关)"
    echo "0. 退出"
    echo ""
}

# 代理设置
setup_proxy() {
    echo -e "${BLUE}代理设置${NC}"
    echo ""
    echo "1. 启用代理环境变量"
    echo "2. 禁用代理环境变量"
    echo "3. 测试代理连接"
    echo "0. 返回"
    echo ""
    
    read -p "请选择操作 [0-3]: " choice
    
    case $choice in
        1)
            enable_proxy_env
            ;;
        2)
            disable_proxy_env
            ;;
        3)
            test_connection
            ;;
        0)
            return
            ;;
        *)
            echo "无效选择"
            ;;
    esac
}

# 启用代理环境变量
enable_proxy_env() {
    local http_port=7890
    local socks_port=7891
    
    if [ -f "$CLASH_CONFIG_DIR/config.yaml" ]; then
        http_port=$(grep "^port:" "$CLASH_CONFIG_DIR/config.yaml" | head -1 | sed 's/port:[[:space:]]*//' | sed 's/[[:space:]]*$//' || echo "7890")
        socks_port=$(grep "^socks-port:" "$CLASH_CONFIG_DIR/config.yaml" | head -1 | sed 's/socks-port:[[:space:]]*//' | sed 's/[[:space:]]*$//' || echo "7891")
    fi
    
    echo "启用代理环境变量..."
    export http_proxy=http://127.0.0.1:$http_port
    export https_proxy=http://127.0.0.1:$http_port
    export HTTP_PROXY=http://127.0.0.1:$http_port
    export HTTPS_PROXY=http://127.0.0.1:$http_port
    export all_proxy=socks5://127.0.0.1:$socks_port
    export ALL_PROXY=socks5://127.0.0.1:$socks_port
    export no_proxy="localhost,127.0.0.1,::1"
    export NO_PROXY="localhost,127.0.0.1,::1"
    
    echo -e "${GREEN}代理环境变量已启用${NC}"
    echo "HTTP 代理: http://127.0.0.1:$http_port"
    echo "SOCKS5 代理: socks5://127.0.0.1:$socks_port"
}

# 禁用代理环境变量
disable_proxy_env() {
    echo "禁用代理环境变量..."
    unset http_proxy https_proxy HTTP_PROXY HTTPS_PROXY all_proxy ALL_PROXY
    echo -e "${GREEN}代理环境变量已禁用${NC}"
}

# 节点管理
manage_nodes() {
    echo -e "${BLUE}节点管理${NC}"
    echo ""
    echo "1. 查看节点列表"
    echo "2. 测试节点延迟"
    echo "3. 切换节点"
    echo "0. 返回"
    echo ""
    
    read -p "请选择操作 [0-3]: " choice
    
    case $choice in
        1)
            list_nodes
            ;;
        2)
            test_nodes
            ;;
        3)
            switch_node
            ;;
        0)
            return
            ;;
        *)
            echo "无效选择"
            ;;
    esac
}

# 列出节点
list_nodes() {
    echo -e "${BLUE}节点列表:${NC}"
    echo ""
    
    if [ -f "$CLASH_CONFIG_DIR/config.yaml" ]; then
        # 提取节点信息
        python3 -c "
import yaml
import sys

try:
    with open('$CLASH_CONFIG_DIR/config.yaml', 'r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    
    proxies = config.get('proxies', [])
    proxy_groups = config.get('proxy-groups', [])
    
    print('代理节点:')
    for i, proxy in enumerate(proxies, 1):
        print(f'  {i}. {proxy.get(\"name\", \"未知\")} ({proxy.get(\"type\", \"未知\")})')
    
    print('\n代理组:')
    for group in proxy_groups:
        print(f'  - {group.get(\"name\", \"未知\")} ({group.get(\"type\", \"未知\")})')
        
except Exception as e:
    print(f'读取配置失败: {e}')
" 2>/dev/null || echo "无法读取节点信息"
    fi
}

# 测试节点延迟
test_nodes() {
    echo -e "${BLUE}测试节点延迟...${NC}"
    echo "此功能需要 Clash API 支持，开发中..."
}

# 切换节点
switch_node() {
    echo -e "${BLUE}切换节点${NC}"
    echo "此功能需要 Clash API 支持，开发中..."
}

# 主循环
main() {
    # 检测环境
    detect_config_dir
    detect_clash_bin
    
    while true; do
        show_menu
        read -p "请选择操作 [0-10]: " choice
        
        case $choice in
            1)
                start_service
                read -p "按回车键继续..."
                ;;
            2)
                stop_service
                read -p "按回车键继续..."
                ;;
            3)
                restart_service
                read -p "按回车键继续..."
                ;;
            4)
                show_service_info
                read -p "按回车键继续..."
                ;;
            5)
                update_subscription
                read -p "按回车键继续..."
                ;;
            6)
                view_logs
                read -p "按回车键继续..."
                ;;
            7)
                test_connection
                read -p "按回车键继续..."
                ;;
            8)
                setup_proxy
                ;;
            9)
                manage_nodes
                ;;
            10)
                system_proxy_menu
                ;;
            0)
                echo -e "${GREEN}再见！${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}无效选择，请重试${NC}"
                sleep 1
                ;;
        esac
    done
}

# 运行主程序
main "$@"

# ===== 新增：系统代理菜单 =====
system_proxy_menu() {
    clear
    echo -e "${BLUE}系统代理开关${NC}"
    echo ""
    echo "1. 开启（自动判断作用域）"
    echo "2. 关闭（自动判断作用域）"
    echo "3. 仅开启用户级代理"
    echo "4. 仅关闭用户级代理"
    echo "5. 仅开启系统级代理 (root)"
    echo "6. 仅关闭系统级代理 (root)"
    echo "0. 返回"
    echo ""
    read -p "请选择 [0-6]: " op

    # 引入 manager 以使用其封装
    if [ -d "/etc/clash/.." ]; then :; fi
    # 直接定位项目的 lib 目录（安装后可能不可见，此处走轻量逻辑）
    local lib_dir="/etc/clash/../clash-installer/lib"
    if [ -f "$lib_dir/manager.sh" ]; then
        source "$lib_dir/manager.sh" 2>/dev/null || true
    fi
    # 再尝试从可见位置加载 proxy 能力
    if [ -z "$(type -t enable_system_proxy)" ]; then
        # 最后回退：内联调用 lib/proxy.sh，如果存在配置目录上级的安装器
        if [ -f "$lib_dir/proxy.sh" ]; then
            source "$lib_dir/proxy.sh"
        fi
    fi

    case "$op" in
        1)
            if type enable_system_proxy >/dev/null 2>&1; then
                enable_system_proxy
            else
                # 直接调用 proxy_on 自动判断
                if type proxy_on >/dev/null 2>&1; then proxy_on; else echo "功能不可用"; fi
            fi
            read -p "按回车返回..." _
            ;;
        2)
            if type disable_system_proxy >/dev/null 2>&1; then
                disable_system_proxy
            else
                if type proxy_off >/dev/null 2>&1; then proxy_off; else echo "功能不可用"; fi
            fi
            read -p "按回车返回..." _
            ;;
        3)
            if type proxy_on >/dev/null 2>&1; then proxy_on --user; else echo "功能不可用"; fi
            read -p "按回车返回..." _
            ;;
        4)
            if type proxy_off >/dev/null 2>&1; then proxy_off --user; else echo "功能不可用"; fi
            read -p "按回车返回..." _
            ;;
        5)
            if type proxy_on >/dev/null 2>&1; then proxy_on --system; else echo "功能不可用"; fi
            read -p "按回车返回..." _
            ;;
        6)
            if type proxy_off >/dev/null 2>&1; then proxy_off --system; else echo "功能不可用"; fi
            read -p "按回车返回..." _
            ;;
        0)
            return ;;
        *)
            echo "无效选择"; sleep 1 ;;
    esac
}
