#!/usr/bin/env bash
# Clash 轻量级交互控制台

set -euo pipefail

# ===== 路径解析 =====
# 优先使用注入的 LIB_DIR（安装脚本设置），否则自动推导
if [ -z "${LIB_DIR:-}" ]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    
    # 开发环境：脚本在项目 bin/ 目录下
    if [ -d "$(dirname "$SCRIPT_DIR")/lib" ]; then
        LIB_DIR="$(dirname "$SCRIPT_DIR")/lib"
    # 安装环境：默认安装路径
    elif [ -d "/usr/local/share/clash-installer/lib" ]; then
        LIB_DIR="/usr/local/share/clash-installer/lib"
    else
        echo "错误: 找不到 Clash 库目录" >&2
        echo "请确保已正确安装 Clash，或设置 LIB_DIR 环境变量" >&2
        exit 1
    fi
fi

# 验证库目录是否存在
if [ ! -d "$LIB_DIR" ]; then
    echo "错误: 库目录不存在: $LIB_DIR" >&2
    exit 1
fi

# 加载共享库
source "$LIB_DIR/common.sh"
get_install_paths
init_logging
source "$LIB_DIR/manager.sh"

# ===== UI 辅助函数 =====
print_header() {
    clear 2>/dev/null || true
    echo -e "${BLUE}╔══════════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║              Clash 控制中心                  ║${NC}"
    echo -e "${BLUE}╚══════════════════════════════════════════════╝${NC}"
    echo
}

status_summary() {
    local status_text
    if status_text=$(get_status); then
        echo -e "  当前状态 : ${GREEN}${status_text}${NC}"
    else
        echo -e "  当前状态 : ${RED}${status_text}${NC}"
    fi

    local http_port socks_port api_port
    http_port=$(get_config_value "install.http_port" "7890")
    socks_port=$(get_config_value "install.socks_port" "7891")
    api_port=$(get_config_value "install.api_port" "9090")

    echo -e "  HTTP 代理 : ${CYAN}http://127.0.0.1:${http_port}${NC}"
    echo -e "  SOCKS5 代理 : ${CYAN}socks5://127.0.0.1:${socks_port}${NC}"
    echo -e "  控制面板 : ${CYAN}http://127.0.0.1:${api_port}${NC}"

    echo
    echo -e "  端口状态 :"
    while IFS= read -r line; do
        line="${line//✓/${GREEN}✓${NC}}"
        line="${line//✗/${RED}✗${NC}}"
        echo "    ${line}"
    done < <(check_ports)
    echo
}

show_menu() {
    print_header
    status_summary
    cat <<'MENU'
  1. 启动代理
  2. 关闭代理
  3. 查看运行状态
  4. 查看最近日志
  5. 更新订阅
  6. 网络诊断
  0. 退出
MENU
    echo -n "请选择操作 [0-6]: "
}

pause() {
    read -rp "按回车返回主菜单..." _
}

# ===== 功能封装 =====
start_proxy() {
    local started=true

    if ! start_service; then
        started=false
    fi

    if $started; then
        if ! proxy_on; then
            warn "Clash 已启动，但未能自动配置系统代理，请检查权限"
        else
            success "网络代理已开启"
        fi
    fi

    $started
}

stop_proxy() {
    local ok=true

    if ! proxy_off; then
        warn "未检测到需要恢复的系统代理或权限不足"
        ok=false
    fi

    if ! stop_service; then
        ok=false
    else
        success "Clash 已关闭，网络路径已恢复"
    fi

    $ok
}

show_status() {
    echo
    status_summary
}

show_logs() {
    echo
    view_logs 40 || true
    echo
}

perform_update() {
    echo
    update_subscription || true
    echo
}

run_diagnostics() {
    echo
    test_connection || true
    echo
}

# ===== 命令模式 =====
show_help() {
    cat <<'HELP'
Clash 控制中心

用法: clash-cli [命令]

命令:
  start      启动 Clash 并开启系统代理
  stop       停止 Clash 并恢复网络路径
  status     查看当前运行状态
  logs       查看最近日志
  update     更新订阅配置
  diagnose   运行网络连通性诊断
  menu       打开交互式控制台 (默认)
  help       显示本帮助信息
HELP
}

handle_command() {
    local cmd="${1:-menu}"
    case "$cmd" in
        start)
            start_proxy
            ;;
        stop)
            stop_proxy
            ;;
        status)
            show_status
            ;;
        logs)
            show_logs
            ;;
        update)
            perform_update
            ;;
        diagnose|diag)
            run_diagnostics
            ;;
        help|-h|--help)
            show_help
            ;;
        menu)
            return 1
            ;;
        *)
            error "未知命令: $cmd"
            echo
            show_help
            ;;
    esac

    exit 0
}

# 如果提供了命令，优先处理
if [ "$#" -gt 0 ]; then
    handle_command "$1" || true
fi

# ===== 交互式循环 =====
while true; do
    show_menu
    read -r choice
    echo
    case "$choice" in
        1)
            start_proxy
            pause
            ;;
        2)
            stop_proxy
            pause
            ;;
        3)
            show_status
            pause
            ;;
        4)
            show_logs
            pause
            ;;
        5)
            perform_update
            pause
            ;;
        6)
            run_diagnostics
            pause
            ;;
        0)
            echo -e "${GREEN}再见！${NC}"
            exit 0
            ;;
        *)
            warn "无效选择，请重新输入"
            pause
            ;;
    esac
    echo
done
